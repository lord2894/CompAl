<!doctype html>
<!--[if lt IE 7]>
<html class="ie6 oldie"> <![endif]-->
<!--[if IE 7]>
<html class="ie7 oldie"> <![endif]-->
<!--[if IE 8]>
<html class="ie8 oldie"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="">
<!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Компьютерная алгебра</title>
    <link href="boilerplate.css" rel="stylesheet" type="text/css">
    <link href="style.css" rel="stylesheet" type="text/css">
    <!--
    To learn more about the conditional comments around the html tags at the top of the file:
    paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/

    Do the following if you're using your customized build of modernizr (http://www.modernizr.com/):
    * insert the link to your js here
    * remove the link below to the html5shiv
    * add the "no-js" class to the html tags at the top
    * you can also remove the link to respond.min.js if you included the MQ Polyfill in your modernizr build
    -->
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <script src="respond.min.js"></script>
    <script src="jquery-2.1.1.min.js"></script>
</head>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<div id="header" class="fluid">
    <hgroup id="head" class="fluid">
        <div id="head_text" class="fluid">
            <header id="header_t" class="fluid">Компьютерная алгебра v2.0 </header>
        </div>
        <div id="description" class="fluid">Данный сервис предназначен для предоставления пользователю возможности
            увидеть любое рациональное выражение (знаки + - * / ) в виде дерева его решения.
        </div>
        <div id="example" class="fluid">Пример входных данных: 4.5-6/(1-2.5)^2-1<br>
            Внимание! Для ввода доступны только следующие символы: . 0-9 + - * / ^ ( ) a-z A-Z 0-9
            Возможность ввода других символов отключена из соображений безопасности.<br>
        </div>
        <div id="ds_area" class="fluid">Узлы операций в построенном дереве интерактивны, при нажатии на один из них появится результат вычисления его поддерева. <br>
            В данной версии сайта доступен ввод переменных, имя переменной должно начинаться с буквы(a-zA-Z) и далее содержать любые символы из данного набора a-z A-Z 0-9 и _.<br>
        </div>
    </hgroup>
</div>
<div id="navigation_panel" class="fluid">
    <form id="mainForm">
        <label for="racText">Введите рациональное выражение:</label>
        <input name="racText" type="text" class="textbox" id="racText" size="50">
        <input type="button" name="generateBtn" id="generateBtn" value="Генерировать дерево" class="button">
    </form>
</div>
<hgroup id="error_area" class="fluid">
    <div id="error_text" class="fluid"></div>
</hgroup>
<div id="svg_panel" class="fluid">
    <svg>
         <g>
         </g>
    </svg>
</div>
<footer id="e-mail_area" class="fluid"><a href="mailto:ivanov.kir.m@yandex.ru"></a>Проект подготовлен Ивановым Кириллом,
    группа 402 ФКН ПМИ НИУ-ВШЭ. Мой адрес электронной почты: <a href="mailto:ivanov.kir.m@yandex.ru">ivanov.kir.m@yandex.ru</a>
</footer>
<script>
function page() {  //Добавить возможность переменных
    d3.select("#navigation_panel").select("#generateBtn").attr('onclick', 'generateTree()');
    var input = document.getElementById("racText");
    input.oninput = function () {
        var re = new RegExp("[^0-9\\-\\.\\+\\^\\/\\*\\(\\)\\:\\,A-Za-z_]");
        //var check = input.value + String.fromCharCode(e.charCode);
        var check = input.value;
        var change = true;
        if (re.test(check)) {
            while (change) {
                var length = check.length;
                check = check.replace(re, '');
                if (length == check.length)
                    change = false;
            }
            input.value = check;
            return false;
        }
    };
    input.onkeypress = function (e) {
        if (event.keyCode == 13) {
            event.preventDefault();
            generateTree();
        }
    };

    var svg_panel = document.getElementById("svg_panel");
    var margin = {top: 20, right: 120, bottom: 20, left: 120},
            width = 1500 - margin.right - margin.left,
            height = 1500 - margin.top - margin.bottom;
    var tree = d3.layout.tree()
            .size([height, width]);
    var diagonal = d3.svg.diagonal()
            .projection(function (d) {
                return [d.x, d.y];
            });
    var svg = d3.select("body").select("#svg_panel").select("svg").attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .select("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
//
    var cur_sim = 0;
    var i = 0;
    var dataMap;
    var data;
    var treeData;
    var operation_nodes = [];
    var variables = [];
    var tooltips = [];
    document.getElementById("error_text").innerHTM = "";
    checkOperation = function (symbol) {
        symbol = symbol.toString();
        regexp = new RegExp("^[\\^\\+\\-\\*\\/]+$");
        return regexp.test(symbol);
    }
    checkBinary = function (symbol) {
        symbol = symbol.toString();
        regexp = new RegExp("[\\^\\+\\-\\*\\/]+");
        return regexp.test(symbol);
    }
    checkUnary = function (symbol) {
        return false;
    }
    checkPriority = function (op_1, op_2) {
        var op1pr, op2pr;
        if (op_1 == '^') op1pr = 1;
        if (op_2 == '^') op2pr = 1;
        if (op_1 == '*' || op_1 == '/') op1pr = 0.5;
        if (op_2 == '*' || op_2 == '/') op2pr = 0.5;
        if (op_1 == '+' || op_1 == '-') op1pr = 0.1;
        if (op_2 == '+' || op_2 == '-') op2pr = 0.1;
        //if (op_1 == '(') op_1pr = 0;
        if (op_2 == '(') op_2pr = 0;
        return op1pr - op2pr;
    }
    checkSTRtrubles = function (equalSTR) {
        regexp = new RegExp("error[0-9]");
        return regexp.test(equalSTR);
    }
    checkSTRoperations = function (equalSTR) {
        var re1 = new RegExp("[\\^\\+\\-\\*\\/]{3,}");
        var re2 = new RegExp("\\-[\\^\\+\\*\\/]{2,}");
        //var re3 = new RegExp("[\\^\\+\\*\\/]{2,}");
        if (re1.test(equalSTR) || re2.test(equalSTR)) {
            return "error3";
        }
        else {
            return equalSTR;
        }
    }
    polishNotation = function (equalSTR) {
        var re1 = new RegExp("[\\^\\+\\-\\*\\/]{3,}");
        var re2 = new RegExp("\\-[\\^\\+\\*\\/]{1,}");
        var re3 = new RegExp("[\\^\\+\\*\\/]{2,}");
        var re4 = new RegExp("[a-zA-Z_]");
        var re5 = new RegExp("[0-9a-zA-Z_]");
        if (re1.test(equalSTR) || re2.test(equalSTR) || re3.test(equalSTR)) {
            return return_string = "error3";
        }
        else {
            var unary_minus = false;
            var stack = [];
            var N = equalSTR.length;
            var return_string = "";
            for (var i = 0; i < N; i++) {
                var current_symbol = equalSTR.charAt(i);
                if ((current_symbol >= '0' && current_symbol <= '9')) {
                    if ((current_symbol >= '1' && current_symbol <= '9')) {
                        return_string += '#';
                        if (unary_minus == true) {
                            return_string += '-';
                            unary_minus = false;
                        }
                        var dot = false;
                        while ((current_symbol >= '0' && current_symbol <= '9') || current_symbol == '.') {
                            if (current_symbol == '.' && dot == false)
                                dot = true;
                            else if (current_symbol == '.' && dot == true) {
                                return return_string = "error2";
                            }
                            return_string += (current_symbol);
                            current_symbol = equalSTR.charAt(++i);
                        }
                        if (re4.test(current_symbol)) {
                            return return_string = "error4";
                        }
                        i--;
                    }
                    else if (current_symbol == '0') {
                        if (i == 0 || i == equalSTR.length - 1) {
                            return_string += '#';
                            return_string += '0';
                            //i--;
                            continue
                        }
                        else {
                            current_symbol = equalSTR.charAt(++i);
                            if (current_symbol == '.') {
                                i--;
                                continue;
                            }
                            else if (current_symbol == ')' || current_symbol == '(' || checkOperation(current_symbol)) {
                                return_string += '#';
                                return_string += '0';
                                i--;
                                continue
                            }
                            /*else if (current_symbol == '(' || checkOperation(current_symbol)) {
                             return_string += '#';
                             return_string += '0';
                             i--;
                             continue
                             }*/
                            else return return_string = "error4"
                        }
                    }
                }
                else if (re4.test(current_symbol)){
                    return_string += '#';
                    if (unary_minus == true) {
                        return_string += '-';
                        unary_minus = false;
                    }
                    while (re5.test(current_symbol)) {
                        return_string += (current_symbol);
                        current_symbol = equalSTR.charAt(++i);
                    }
                    i--;
                }
                else if (current_symbol == ')') {
                    while (stack.length >= 0 && current_symbol != '(') {
                        current_symbol = stack.pop();
                        if (current_symbol != '(')
                            return_string += (current_symbol);
                    }
                    if (stack.length == 0 && current_symbol != '(') {
                        return return_string = "error1";
                    }
                }
                else if (checkOperation(current_symbol)) {
                    var re = new RegExp("[0-9a-zA-Z_]");
                    if (current_symbol == '-') {
                        if ((i == 0 || (i > 0 && (checkOperation(equalSTR.charAt(i - 1)) || equalSTR.charAt(i - 1) == '(')))
                                && (i + 1 < equalSTR.length
                                        && ((re.test(equalSTR.charAt(i+1)))
                                                || equalSTR.charAt(i + 1) == '.' ))) {
                            unary_minus = true;
                            continue;
                        }
                        else {
                            while (checkPriority(current_symbol, stack[stack.length - 1]) <= 0) {
                                return_string += (stack.pop());
                            }
                        }
                    }
                    else {
                        while (checkPriority(current_symbol, stack[stack.length - 1]) <= 0) {
                            return_string += (stack.pop());
                        }
                    }
                    stack.push(current_symbol);
                }
                else if (current_symbol == '(') {
                    stack.push(current_symbol);
                }
                else if (current_symbol == '.') {
                    current_symbol = equalSTR.charAt(++i);
                    if ((current_symbol >= '0' && current_symbol <= '9')) {
                        var cur_num = '#';
                        if (unary_minus == true) {
                            unary_minus = false;
                            cur_num += '-';
                        }
                        cur_num += '0';
                        cur_num += '.';
                        var dot = true;
                        while ((current_symbol >= '0' && current_symbol <= '9') || current_symbol == '.') {
                            if (current_symbol == '.' && dot == true) {
                                return return_string = "error2";
                            }
                            cur_num += (current_symbol);
                            current_symbol = equalSTR.charAt(++i);
                        }
                        if (re4.test(current_symbol)) {
                            return return_string = "error4";
                        }
                        var re0 = new RegExp("^#[0\\.]+$");
                        if (re0.test(cur_num)) {
                            cur_num = "#0";
                        }
                        return_string = return_string + cur_num;
                        i--;
                    } else return return_string = "error4"
                }
                else return return_string = "error4";
            }
            while (stack.length != 0) {
                var cur = stack.pop()
                if (cur == '(') {
                    return return_string = "error1";
                } else
                    return_string += cur;
            }
            return return_string;
        }
    }
    recursiveData = function (cur_pos, equalSTR) {
        var re4 = new RegExp("[a-zA-Z_]");
        var re5 = new RegExp("[0-9a-zA-Z_\\.]");
        var operands = 0;
        cur_sim = cur_pos - 1;
        if (cur_pos >= 0 && checkBinary(equalSTR[cur_pos])) {
            while (operands != 2) {
                   if (cur_sim >= 0 && re5.test(equalSTR[cur_sim])) {
                    var k = 0;
                    var numSTR = "";
                    while (cur_sim - k >= 0 && equalSTR[cur_sim - k] != '#') {
                        numSTR += equalSTR[cur_sim - k];
                        k++;
                    }
                    numSTR = numSTR.split("").reverse().join("");
                    data.push({"name": numSTR, "parent": equalSTR[cur_pos], "parentID": cur_pos, "nameID": cur_sim - k});
                    operands++;
                    cur_sim = cur_sim - k - 1;
                    continue;
                }
                else if (cur_sim >= 0 && checkOperation(equalSTR[cur_sim])) {
                    data.push({"name": equalSTR[cur_sim], "parent": equalSTR[cur_pos], "parentID": cur_pos, "nameID": cur_sim});
                    operands++;
                    recursiveData(cur_sim, equalSTR);
                    continue;
                }
                else if (cur_sim < 0 && operands != 2) {
                    //data=[];
                    //data.push({"name": "Ошибка! Для операции " + equalSTR[cur_pos]+ " не хватает операндов.", "parent": "start", "parentID": -1, "nameID": 0});
                    document.getElementById("error_text").innerHTML = "Ошибка! Для операции " + equalSTR[cur_pos] + " не хватает операндов.";
                    return;
                }
            }
        }
        else if (checkUnary(equalSTR[cur_pos])) {
            while (operands != 2) {
                if (cur_sim >= 0 && equalSTR[cur_sim] >= '0' && equalSTR[cur_sim] <= '9') {
                    var k = 0;
                    var numSTR = "";
                    while (cur_sim - k >= 0 && equalSTR[cur_sim - k] != '#') {
                        numSTR.add(equalSTR[cur_sim - k]);
                        k++;
                    }
                    numSTR = numSTR.split("").reverse().join("");
                    data.push({"name": numSTR, "parent": equalSTR[cur_pos], "parentID": cur_pos, "nameID": cur_sim - k});
                    cur_sim = cur_sim - k - 1;
                    operands++;
                    continue;
                }
                else if (cur_sim >= 0 && checkOperation(equalSTR[cur_sim])) {
                    data.push({"name": equalSTR[cur_sim], "parent": equalSTR[cur_pos], "parentID": cur_pos, "nameID": cur_sim});
                    operands++;
                    recursiveData(cur_sim, equalSTR);
                    continue;
                }
            }
        }
    }
    generateTree = function () {
        clearPage();
        data = [
        ];
        var equalSTR = document.getElementById("racText").value;
        var re = new RegExp("([0-9a-zA-Z_]\\()");
        while(equalSTR.search(re) != -1)
        {
            var ix =equalSTR.search(re);
            equalSTR = equalSTR.substr(0,ix+1)+"*"+equalSTR.substr(ix+1);
        };
        re = new RegExp("(\\)[0-9a-zA-Z_])");
        while(equalSTR.search(re) != -1)
        {
            var ix =equalSTR.search(re);
            equalSTR = equalSTR.substr(0,ix+1)+"*"+equalSTR.substr(ix+1);
        };
        re = new RegExp("\\:");
        while(equalSTR.search(re) != -1)
        {
            var ix =equalSTR.search(re);
            equalSTR=equalSTR.substr(0,ix)+"/"+equalSTR.substr(ix+1);
        };
        re = new RegExp("\\,");
        while(equalSTR.search(re) != -1)
        {
            var ix =equalSTR.search(re);
            equalSTR=equalSTR.substr(0,ix)+"."+equalSTR.substr(ix+1);
        };
        //equalSTR = equalSTR re
        equalSTR = polishNotation(equalSTR);
        if (!checkSTRtrubles(equalSTR)) {
            var regVar = new RegExp("[0-9A-Za-z_\\.]");
            //data.push({"name": equalSTR[equalSTR.length - 1], "parent": "start", "parentID": -1, "nameID": equalSTR.length - 1});
            cur_sim = equalSTR.length - 1
            if (cur_sim >= 0 && regVar.test(equalSTR[cur_sim])) {
                var k = 0;
                var numSTR = "";
                while (cur_sim - k >= 0 && equalSTR[cur_sim - k] != '#') {
                    numSTR += equalSTR[cur_sim - k];
                    k++;
                }
                numSTR = numSTR.split("").reverse().join("");
                data.push({"name": numSTR, "parent": "start", "parentID": -1, "nameID": cur_sim - k});
                cur_sim = cur_sim - k - 1;
            }
            else if (cur_sim >= 0 && checkOperation(equalSTR[cur_sim])) {
                data.push({"name": equalSTR[cur_sim], "parent": "start", "parentID": -1, "nameID": cur_sim});
            }
            //current_position = equalSTR.length - 1;
            recursiveData(cur_sim, equalSTR);
            if (document.getElementById("error_text").innerHTML.search("Ошибка!") == -1) {
                dataMap = data.reduce(function (map, node) {
                    map[node.name + node.nameID] = node;
                    return map;
                }, {});
                treeData = [];
                data.forEach(function (node) {
                    // add to parent
                    var parent = dataMap[node.parent + node.parentID];
                    if (parent) {
                        // create child array if it doesn't exist
                        (parent.children || (parent.children = []))
                            // add node to child array
                                .push(node);
                        //root = treeData[0];
                        //update(root);
                    } else {
                        // parent is null or missing
                        treeData.push(node);
                        //root = treeData[0];
                        //update(root);
                    }
                });
                root = treeData[0];
                update(root);
            }
        }
        else {
            data = [];
            if (equalSTR[equalSTR.length - 1] == '1') {
                document.getElementById("error_text").innerHTML = "Ошибка! Нет согласования скобок.";
                //data.push({"name": "Ошибка! Не согласование скобок.", "parent": "start", "parentID": -1, "nameID": 1});
            }
            if (equalSTR[equalSTR.length - 1] == '2') {
                document.getElementById("error_text").innerHTML = "Ошибка! В выражении присутствует лишняя точка(.).";
                //data.push({"name": "Ошибка! В выражении присутствует\nлишняя точка(.).", "parent": "start", "parentID": -1, "nameID": 2});
            }
            if (equalSTR[equalSTR.length - 1] == '3') {
                document.getElementById("error_text").innerHTML = "Ошибка! В выражении присутствуют лишние знаки операций.";
                //data.push({"name": "Ошибка! В выражении присутствуют лишние знаки операций.", "parent": "start", "parentID": -1, "nameID": 3});
            }
            if (equalSTR[equalSTR.length - 1] == '4') {
                document.getElementById("error_text").innerHTML = "Ошибка! Непредвиденный символ.";
                //data.push({"name": "Ошибка! В выражении присутствуют лишние знаки операций.", "parent": "start", "parentID": -1, "nameID": 3});
            }
        }
    }
    clearPage = function () {
        i = 0;
        operation_nodes = [];
        variables = [];
        for (var k=0; k<tooltips.length; k++)
        {
            tooltips[k].remove();
        }
        tooltips = [];
        var node = svg.selectAll("g.node");
        if (node) node.remove();
        var link = svg.selectAll("path.link");
        if (link) link.remove();
        document.getElementById("error_text").innerHTML = "";
    }
    update = function (source) {
        // Compute the new tree layout.
        var nodes = tree.nodes(root).reverse(),
                links = tree.links(nodes);

        // Normalize for fixed-depth.
        nodes.forEach(function (d) {
            d.y = d.depth * 100;
            //d.x = d.x * 0.5;
            d.x = (width - d.x) * 0.5;
        });

        // Declare the nodes…
        var node = svg.selectAll("g.node")
                .data(nodes, function (d) {
                    return d.id || (d.id = ++i);
                });

        // Enter the nodes.
        var nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                }).attr("id", function (d) {
                    return d.id;
                });

        nodeEnter.append("circle")
                .attr("r", 10);

       nodeEnter.append("text")
                .attr("x", function (d) {
                    return d.children || d._children ? -13 : 13;
                })
                .attr("dy", ".35em")
                .attr("text-anchor", function (d) {
                    return d.children || d._children ? "end" : "start";
                })
                .text(function (d) {
                    return d.name;
                })
                .style("fill-opacity", 1);

        /*nodeEnter.append("foreignObject")
                .attr("x", function (d) {
                    return d.children || d._children ? -13 : 13;
                })
                .attr("dy", ".35em")
                .attr("width","100")
                .attr("height","30")
                .append("xhtml:input")
                .attr("class","inputtext")
                .attr("type","text")
                .attr("width","100")
                .attr("height","30");
                //.attr("display","block");*/

        // Declare the links…
        var link = svg.selectAll("path.link")
                .data(links, function (d) {
                    return d.target.id;
                });

        // Enter the links.
        link.enter().insert("path", "g")
                .attr("class", "link")
                .attr("id", function (d) {
                    return d.source.id;
                })
                .attr("d", diagonal);

        SetOnClick(source);
        if (variables.length == 0)
            operation_nodes[operation_nodes.length - 1].onclick();
    }
    SetOnClick = function (source) {
        data = data.reverse();
        var nodes = tree.nodes(root).reverse();
        var node = svg.selectAll("g.node");
        var nodeEnter = svg.selectAll("g.node")
                .data(nodes, function (d) {
                    return d.id || (d.id = ++i);
                }).enter();
        var regVar = new RegExp("\\-?[A-Za-z_]{1}[A-Za-z0-9_]*");
        for (var i = 0; i < node[0].length; i++) {
            if (checkOperation(node[0][i].textContent)) {
                node[0][i].onclick = function () {
                    this.children[0].style.fill = "4242CC";
                    for (var k = 0; k < operation_nodes.length; k++) {
                        if (operation_nodes[k] != this)
                            operation_nodes[k].children[0].style.fill = "FF4344";
                    }
                    NodeOnClick(this);
                };
                node[0][i].style.cursor = "pointer";
                node[0][i].children[0].style.fill = "FF4344";
                node[0][i].onmouseover = function () {
                    this.children[0].style.stroke = "2AF43C";
                };
                node[0][i].onmouseout = function () {
                    this.children[0].style.stroke = "#f2f444";
                };
                operation_nodes.push(node[0][i]);
            }
            else if (regVar.test(node[0][i].textContent)){
                var varText=node[0][i].textContent;
                var index = parseInt(node[0][i].id) - 1;
                node[0][i].children[1].style.display = "none";
                //node[0][i].children[0].style.display = "none";
                var newElement = document.createElementNS("http://www.w3.org/2000/svg", 'foreignObject');
                //newElement.setAttribute("x",data[index].x > data[data.length-1].x ? -113 : 13);
                newElement.setAttribute("x",-50);
                //newElement.setAttribute("dy",".35em");
                newElement.setAttribute("y",13);
                newElement.setAttribute("width","100");
                newElement.setAttribute("height","30");
                node[0][i].appendChild(newElement);
                var newEl = document.createElement("input");
                newEl.setAttribute("class","inputtext");
                newEl.setAttribute("type","text");
                newEl.setAttribute("width","100");
                newEl.setAttribute("height","30");
                newEl.setAttribute("placeholder",varText);
                newEl.oninput = function(){setNum(this);};
                newEl.style.display="inline-block";
                node[0][i].children[2].appendChild(newEl);
                variables.push(node[0][i]);
                var tooltip = d3.select("body")
                        .append("div")
                        .style("position", "absolute")
                        .style("z-index", "10")
                        .style("visibility", "hidden")
                        .style("background","#000000")
                        .style("font-size","20px")
                        .style("border","2px double #5E5E5E")
                        .attr("id","tooltip"+node[0][i].id)
                        .text(varText);
               tooltips.push(tooltip);
               node[0][i].onmouseover = function(){
                   var tooltip = document.getElementById("tooltip"+this.id);
                   return tooltip.style.visibility="visible";
               };
               node[0][i].onmousemove = function(){
                   var tooltip = document.getElementById("tooltip"+this.id);
                    tooltip.style.top = event.pageY-10+"px";
                    tooltip.style.left = event.pageX+10+"px";
                   return;
               };
               node[0][i].onmouseout = function(){
                   var tooltip = document.getElementById("tooltip"+this.id);
                   return tooltip.style.visibility = "hidden";
               };
            }
        }
    }
    NodeOnClick = function (node) {
        var index = parseInt(node.id) - 1;
        var regVar = new RegExp("[A-Za-z_]{1}[A-Za-z0-9_]*");
        if (checkBinary(node.textContent)) {
            var operands = [];
            for (var i = data[index].children.length - 1; i >= 0; i--) {
                if (parseFloat(data[index].children[i].name)) {
                    operands.push(parseFloat(data[index].children[i].name));
                }
                else if (regVar.test(data[index].children[i].name)) {
                    var idnode = parseInt(data[index].children[i].id) - 1;
                    var varNode = svg.selectAll("g.node")[0][idnode];
                    var num = varNode.children[2].children[0].value;
                    var re0 = new RegExp("^[0\\.]{1}0*$");
                    if (re0.test(num)) {
                        operands.push(0);
                    }
                    else {
                        var regFloat1 = new RegExp("^\\-?[1-9][0-9]*\\.[0-9]*[1-9]+$");
                        var regFloat2 = new RegExp("^\\-?\\.[0-9]*[1-9]+$")
                        var regInt = new RegExp("^\\-?[1-9][0-9]*$");
                        if (regInt.test(num) || regFloat1.test(num) || regFloat2.test(num)) {
                            var o = parseFloat(num);
                            if (varNode.textContent[0]=='-')
                                    o=-1*o;
                            //if (num[0]='-')
                            //        o=-1*o;
                            operands.push(o);
                        }
                        else {
                            document.getElementById("error_text").innerHTML = "Ошибка! Значение переменной " + data[index].children[i].name+" = "+ num +" не является числом.";
                            return undefined;
                        }
                    }
                }
                else if (data[index].children[i].name == "0") {
                    operands.push(0);
                }
                else {
                    var idnode = parseInt(data[index].children[i].id) - 1;
                    var new_oper = NodeOnClick(svg.selectAll("g.node")[0][idnode]);
                    if (new_oper != undefined )
                        operands.push(new_oper);
                    else
                        return undefined;
                }
            }
            var res = getResult(operands, node.textContent[0]);
            if (res != undefined) {
                document.getElementById("error_text").innerHTML = "Результат: " + res;
                return res;
            }
            return undefined;
        }
    };
    getResult = function (operands, op) {
        var op1pr, op2pr;
        if (op == '^') return Math.pow(operands[0], operands[1]);
        if (op == '*') return operands[0] * operands[1];
        if (op == '/') {
            if (operands[1] != 0) return operands[0] / operands[1];
            else {
                //clearPage();
                document.getElementById("error_text").innerHTML = "Ошибка! В выражении присутствут деление на 0.";
            }
        }
        if (op == '+') return operands[0] + operands[1];
        if (op == '-') return operands[0] - operands[1];
    };
    setNum = function (input) {
        var check = input.value;
        var re = new RegExp("\\,");
        while (check.search(re) != -1) {
            var ix = check.search(re);
            check = check.substr(0, ix) + "." + check.substr(ix + 1);
        }

        var re = new RegExp("[^-0-9\\.]");
        var change = true;
        if (re.test(check)) {
            while (change) {
                var length = check.length;
                check = check.replace(re, '');
                if (length == check.length)
                    change = false;
            }
            //input.value = check;
            //return false;
        }
         input.value = check;
        var name1=  input.parentNode.parentNode.textContent;
        if (name1[0] == '-')
            name1 = name1.substr(1);
       for (var k = 0; k<variables.length; k++){
           var name2 =  variables[k].textContent;
           if (name2[0] == '-')
               name2 = name2.substr(1);
           if (variables[k] != input.parentNode.parentNode && name1 == name2){
               variables[k].children[2].children[0].value = check;
           }
       }
    }
}
var page = page();
</script>

</body>
</html>
