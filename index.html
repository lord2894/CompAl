<!doctype html>
<!--[if lt IE 7]> <html class="ie6 oldie"> <![endif]-->
<!--[if IE 7]>    <html class="ie7 oldie"> <![endif]-->
<!--[if IE 8]>    <html class="ie8 oldie"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="">
<!--<![endif]-->
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Компьютерная алгебра</title>
<link href="boilerplate.css" rel="stylesheet" type="text/css">
<link href="style.css" rel="stylesheet" type="text/css">
<!-- 
To learn more about the conditional comments around the html tags at the top of the file:
paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/

Do the following if you're using your customized build of modernizr (http://www.modernizr.com/):
* insert the link to your js here
* remove the link below to the html5shiv
* add the "no-js" class to the html tags at the top
* you can also remove the link to respond.min.js if you included the MQ Polyfill in your modernizr build 
-->
<!--[if lt IE 9]>
<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<script src="respond.min.js"></script>
</head>
<body>
	<script src="http://d3js.org/d3.v3.min.js"></script>
	<div id="header" class="fluid">
		<hgroup id="head" class="fluid">
			<div id="head_text" class="fluid"><header id="header_t" class="fluid">Компьютерная алгебра</header></div>
			<div id="description" class="fluid">Данный сервис предназначен для предоставления пользователю возможности увидеть любое рациональное выражение (знаки + - * / ) в виде дерева его решения.</div><div id="example" class="fluid">Пример входных данных: 4.5-6/(1-2.5)^2-1<br>
  Внимание! Для ввода доступны только следующие символы: . 0-9 + - * / ^ ( )
Возможность ввода других символов отключена из соображений безопасности.<br>
			</div>
		</hgroup>
	</div>
<div id="navigation_panel" class="fluid">
<form id="mainForm">
  <label for="racText">Введите рациональное выражение:</label>
  <input name="racText" type="text" id="racText" size="50">
  <input type="button" name="generateBtn" id="generateBtn" value="Генерировать дерево">  
</form>
</div>
<hgroup id="error_area" class="fluid">
  <div id="error_text" class="fluid"></div>
</hgroup>
<div id="svg_panel" class="fluid"><svg><g></g></svg></div>
<footer id="e-mail_area" class="fluid"><a href="mailto:ivanov.kir.m@yandex.ru"></a>Проект подготовлен Ивановым Кириллом, группа 402 ФКН ПМИ НИУ-ВШЭ. Мой адрес электронной почты: <a href="mailto:ivanov.kir.m@yandex.ru">ivanov.kir.m@yandex.ru</a></footer>
<script>
function page(){
    d3.select("#navigation_panel").select("#generateBtn").attr('onclick', 'generateTree()');
    var input = document.getElementById("racText");
    input.oninput = function () {
        var re = new RegExp("[^0-9\-\.\+\^\\/\*\(\)]");
        //var check = input.value + String.fromCharCode(e.charCode);
        var check = input.value;
        var change = true;
        if (re.test(check)) {
            while(change){
                var length = check.length;
                check = check.replace(re, '');
                if (length == check.length)
                    change = false;
            }
            input.value = check;
            return false;
        }
    };
	var svg_panel = document.getElementById("svg_panel");
    var margin = {top: 20, right: 120, bottom: 20, left: 120},
			width = 1500 - margin.right - margin.left,
            height = 1500 - margin.top - margin.bottom;
    var tree = d3.layout.tree()
            .size([height,width]);
    var diagonal = d3.svg.diagonal()
            .projection(function (d) {
                return [d.x, d.y];
            });
    var svg = d3.select("body").select("#svg_panel").select("svg").attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .select("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
 var cur_sim = 0;
    var i = 0;
    var dataMap;
    var data;
    var treeData;

    checkOperation = function (symbol) {
        symbol = symbol.toString();
        regexp = new RegExp("[\\^\\+\\-\\*\\/]+");
        return regexp.test(symbol);
    }
    checkBinary = function (symbol) {
        symbol = symbol.toString();
        regexp = new RegExp("[\\^\\+\\-\\*\\/]+");
        return regexp.test(symbol);
    }
    checkUnary = function (symbol) {
        return false;
    }
    checkPriority = function (op_1, op_2) {
        var op1pr, op2pr;
        if (op_1 == '^') op1pr = 1;
        if (op_2 == '^') op2pr = 1;
        if (op_1 == '*' || op_1 == '/') op1pr = 0.5;
        if (op_2 == '*' || op_2 == '/') op2pr = 0.5;
        if (op_1 == '+' || op_1 == '-') op1pr = 0.1;
        if (op_2 == '+' || op_2 == '-') op2pr = 0.1;
        //if (op_1 == '(') op_1pr = 0;
        if (op_2 == '(') op_2pr = 0;
        return op1pr - op2pr;
    }
    checkSTRtrubles = function(equalSTR)  {
        regexp = new RegExp("error[0-9]");
        return regexp.test(equalSTR);
    }
    checkSTRoperations = function(equalSTR)  {
        regexp = new RegExp("[\\^\\+\\-\\*\\/]{2,}");
        if (re.test(equalSTR)) {
            return "error3";
        }
        else {
            return equalSTR;
        }
    }
    polishNotation = function (equalSTR) {
        re = new RegExp("[\\^\\+\\-\\*\\/]{2,}");
        if (re.test(equalSTR)) {
            return return_string = "error3";
        }
        else {
            var stack = [];
            var N = equalSTR.length;
            var return_string = "";
            for (var i = 0; i < N; i++) {
                var current_symbol = equalSTR.charAt(i);
                if ((current_symbol >= '0' && current_symbol <= '9')) {
                    return_string += '#';
                    var dot = false;
                    while ((current_symbol >= '0' && current_symbol <= '9') || current_symbol == '.') {
                        if (current_symbol == '.' && dot == false)
                            dot = true;
                        else if (current_symbol == '.' && dot == true) {
                            return return_string = "error2";
                        }
                        return_string += (current_symbol);
                        current_symbol = equalSTR.charAt(++i);
                    }
                    i--;
                } else {
                    if (current_symbol == ')') {
                        while (stack.length >= 0 && current_symbol != '(') {
                            current_symbol = stack.pop();
                            if (current_symbol != '(')
                                return_string += (current_symbol);
                        }
                        if (stack.length == 0 && current_symbol != '(') {
                            return return_string = "error1";
                        }
                    } else if (checkOperation(current_symbol)) {
                        while (checkPriority(current_symbol, stack[stack.length - 1]) <= 0) {
                            return_string += (stack.pop());
                        }
                        stack.push(current_symbol);
                    } else if (current_symbol == '(') {
                        stack.push(current_symbol);
                    }
                      else if (current_symbol == '.'){
                        current_symbol = equalSTR.charAt(++i);
                        if ((current_symbol >= '0' && current_symbol <= '9')) {
                            return_string += '#';
                            return_string += '0';
                            return_string += '.';
                            var dot = true;
                            while ((current_symbol >= '0' && current_symbol <= '9') || current_symbol == '.') {
                                if (current_symbol == '.' && dot == true) {
                                    return return_string = "error2";
                                }
                                return_string += (current_symbol);
                                current_symbol = equalSTR.charAt(++i);
                            }
                            i--;
                        } else return return_string = "error4"
                    }
                    else
                        return return_string = "error4";
                }
            }
            while (stack.length != 0) {
                var cur = stack.pop()
                if (cur == '(') {
                    return return_string = "error1";
                } else
                    return_string += cur;
            }
            return return_string;
        }
    }
    recursiveData = function (cur_pos, equalSTR) {
        var operands = 0;
        cur_sim = cur_pos - 1;
        if(cur_pos>=0 && checkBinary(equalSTR[cur_pos]))
        {
            while (operands != 2) {
                if (cur_sim >= 0 && equalSTR[cur_sim] >= '0' && equalSTR[cur_sim] <= '9') {
                    var k = 0;
                    var numSTR = "";
                    while (cur_sim - k >= 0 && equalSTR[cur_sim - k] != '#') {
                        numSTR += equalSTR[cur_sim - k];
                        k++;
                    }
                    numSTR = numSTR.split("").reverse().join("");
                    data.push({"name": numSTR, "parent": equalSTR[cur_pos], "parentID": cur_pos, "nameID": cur_sim-k});
                    operands++;
                    cur_sim=cur_sim - k - 1;
                    continue;
                }
                else if (cur_sim >= 0 && checkOperation(equalSTR[cur_sim]))
                {
                    data.push({"name": equalSTR[cur_sim], "parent": equalSTR[cur_pos], "parentID": cur_pos, "nameID": cur_sim});
                    operands++;
                    recursiveData(cur_sim,equalSTR);
                    continue;
                }
                else if (cur_sim <0 && operands != 2)
                {
                    //data=[];
                    //data.push({"name": "Ошибка! Для операции " + equalSTR[cur_pos]+ " не хватает операндов.", "parent": "start", "parentID": -1, "nameID": 0});
                    document.getElementById("error_text").innerHTML = "Ошибка! Для операции " + equalSTR[cur_pos]+ " не хватает операндов.";
                    return;
                }
            }
        }
        else if(checkUnary(equalSTR[cur_pos]))
        {
            while (operands != 2) {
                if (cur_sim >= 0 && equalSTR[cur_sim] >= '0' && equalSTR[cur_sim] <= '9') {
                    var k = 0;
                    var numSTR = "";
                    while (cur_sim - k >= 0 && equalSTR[cur_sim - k] != '#') {
                        numSTR.add(equalSTR[cur_sim - k]);
                        k++;
                    }
                    numSTR = numSTR.split("").reverse().join("");
                    data.push({"name": numSTR, "parent": equalSTR[cur_pos], "parentID": cur_pos, "nameID": cur_sim-k});
                    cur_sim=cur_sim - k - 1;
                    operands++;
                    continue;
                }
                else if (cur_sim >= 0 && checkOperation(equalSTR[cur_sim]))
                {
                    data.push({"name": equalSTR[cur_sim], "parent": equalSTR[cur_pos], "parentID": cur_pos, "nameID": cur_sim});
                    operands++;
                    recursiveData(cur_sim,equalSTR);
                    continue;
                }
            }
        }
    }
    generateTree = function () {
        clearPage();
        data = [
        ];
        var equalSTR = document.getElementById("racText").value;
        equalSTR = polishNotation(equalSTR);
        if(!checkSTRtrubles(equalSTR)) {
            //data.push({"name": equalSTR[equalSTR.length - 1], "parent": "start", "parentID": -1, "nameID": equalSTR.length - 1});
            cur_sim =  equalSTR.length - 1
            if (cur_sim >= 0 && equalSTR[cur_sim] >= '0' && equalSTR[cur_sim] <= '9') {
                var k = 0;
                var numSTR = "";
                while (cur_sim - k >= 0 && equalSTR[cur_sim - k] != '#') {
                    numSTR += equalSTR[cur_sim - k];
                    k++;
                }
                numSTR = numSTR.split("").reverse().join("");
                data.push({"name": numSTR, "parent": "start", "parentID": -1, "nameID": cur_sim-k});
                cur_sim=cur_sim - k - 1;
            }
            else if (cur_sim >= 0 && checkOperation(equalSTR[cur_sim]))
            {
                data.push({"name": equalSTR[cur_sim], "parent": "start", "parentID": -1, "nameID": cur_sim});
            }
            //current_position = equalSTR.length - 1;
            recursiveData(cur_sim, equalSTR);
            dataMap = data.reduce(function (map, node) {
                map[node.name + node.nameID] = node;
                return map;
            }, {});
            treeData = [];
            data.forEach(function (node) {
                // add to parent
                var parent = dataMap[node.parent + node.parentID];
                if (parent) {
                    // create child array if it doesn't exist
                    (parent.children || (parent.children = []))
                        // add node to child array
                            .push(node);
                    //root = treeData[0];
                    //update(root);
                } else {
                    // parent is null or missing
                    treeData.push(node);
                    //root = treeData[0];
                    //update(root);
                }
            });
            root = treeData[0];
            update(root);
        }
        else {
            data=[];
            if(equalSTR[equalSTR.length-1] == '1')
            {
				document.getElementById("error_text").innerHTML = "Ошибка! Нет согласования скобок.";
                //data.push({"name": "Ошибка! Не согласование скобок.", "parent": "start", "parentID": -1, "nameID": 1});
            }
            if (equalSTR[equalSTR.length-1] == '2'){
				document.getElementById("error_text").innerHTML = "Ошибка! В выражении присутствует\nлишняя точка(.).";
                //data.push({"name": "Ошибка! В выражении присутствует\nлишняя точка(.).", "parent": "start", "parentID": -1, "nameID": 2});
            }
            if (equalSTR[equalSTR.length-1] == '3'){
				document.getElementById("error_text").innerHTML = "Ошибка! В выражении присутствуют лишние знаки операций.";
                //data.push({"name": "Ошибка! В выражении присутствуют лишние знаки операций.", "parent": "start", "parentID": -1, "nameID": 3});
            }
            if (equalSTR[equalSTR.length-1] == '4'){
                document.getElementById("error_text").innerHTML = "Ошибка! Непредвиденный символ.";
                //data.push({"name": "Ошибка! В выражении присутствуют лишние знаки операций.", "parent": "start", "parentID": -1, "nameID": 3});
            }
        }
    }
    clearPage = function(){
        var node = svg.selectAll("g.node");
        if(node) node.remove();
        var link = svg.selectAll("path.link");
        if(link) link.remove();
		document.getElementById("error_text").innerHTML = "";
    }
    update = function(source) {
        // Compute the new tree layout.
        var nodes = tree.nodes(root).reverse(),
                links = tree.links(nodes);

        // Normalize for fixed-depth.
        nodes.forEach(function (d) {
            d.y = d.depth * 100;
			//d.x = d.x * 0.5;
            d.x = (width-d.x)*0.5;
        });

        // Declare the nodes…
        var node = svg.selectAll("g.node")
                .data(nodes, function (d) {
                    return d.id || (d.id = ++i);
                });

        // Enter the nodes.
        var nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                }).attr("id", function(d) {return d.id;});

        nodeEnter.append("circle")
                .attr("r", 10);

        nodeEnter.append("text")
                .attr("x", function (d) {
                    return d.children || d._children ? -13 : 13;
                })
                .attr("dy", ".35em")
                .attr("text-anchor", function (d) {
                    return d.children || d._children ? "end" : "start";
                })
                .text(function (d) {
                    return d.name;
                })
                .style("fill-opacity", 1);

        // Declare the links…
        var link = svg.selectAll("path.link")
                .data(links, function (d) {
                    return d.target.id;
                });

        // Enter the links.
        link.enter().insert("path", "g")
                .attr("class", "link")
                .attr("id", function(d) {
                    return d.source.id;
                })
                .attr("d", diagonal);

        SetOnClick();
    }
    SetOnClick = function() {
        data=data.reverse();
        var node = svg.selectAll("g.node");
        //var link = svg.selectAll("path.link");
        //var nodeEnter = node.selectAll("g");
        //var texts = nodeEnter.selectAll("text");
        for (var i=0; i<node[0].length;i++)
        {
            if (checkOperation(node[0][i].textContent)){
                node[0][i].onclick = function(){NodeOnClick(this)};
                //node[0][i].textContent = node[0][i].textContent + "off";
                node[0][i].children[0].style.fill = "FF4344";
                //document.getElementById("error_text").innerHTML = "Ошибка! Непредвиденный символ.";
            };
        }
    }
    NodeOnClick = function (node) {
        var index = parseInt(node.id) - 1;
        if (checkBinary(node.textContent)) {
            var operands = [];
            for (var i = data[index].children.length-1; i >= 0; i--) {
                if (parseFloat(data[index].children[i].name)) {
                    operands.push(parseFloat(data[index].children[i].name));
                }
                else {
                    var idnode = parseInt(data[index].children[i].id)-1;
                    var new_oper = NodeOnClick(svg.selectAll("g.node")[0][idnode]);
                    operands.push(new_oper);
                }
            }
            var res = getResult(operands, node.textContent[0]);
            document.getElementById("error_text").innerHTML = "Результат: "+res;
            return res;
        }
    };
    getResult = function (operands, op) {
        var op1pr, op2pr;
        if (op == '^') return Math.pow(operands[0], operands[1]);
        if (op == '*') return operands[0]*operands[1];
        if (op == '/') return operands[0]/operands[1];
        if (op == '+') return operands[0]+operands[1];
        if (op == '-') return operands[0]-operands[1];
    }
}
var page = page();			
</script>

</body>
</html>
