<!DOCTYPE html>
<meta charset="utf-8">
<style>
    body {
        width: 960px;
        margin: 10px auto;
    }

    #navigation_panel {
        background: #555;
    }

    #navdiv button {
        vertical-align: middle;
    }

    .node circle {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 3px;
    }

    .node text {
        font: 12px sans-serif;
    }

    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 2px;
    }
</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
    function page(){
    d3.select("body").append("div").attr('id', 'navigation_panel');
    d3.select("#navigation_panel").append("input").attr('type', 'text').attr('id', 'equalText'); //.select('#equalText').value="Set equal here"
    d3.select("#navigation_panel").append("button").attr('type', 'button').attr('onclick', 'generateTree()').text('Generate tree from equals');
    var margin = {top: 20, right: 120, bottom: 20, left: 120},
            width = 960 - margin.right - margin.left,
            height = 500 - margin.top - margin.bottom;
    var tree = d3.layout.tree()
            .size([height, width]);
    var diagonal = d3.svg.diagonal()
            .projection(function (d) {
                return [d.y, d.x];
            });
    var svg = d3.select("body").append("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var cur_sim = 0;
    var i = 0;
    var dataMap;
    var data;
    var treeData;
    checkOperation = function (symbol) {
        symbol = symbol.toString();
        regexp = new RegExp("[\\^\\+\\-\\*\\/]+");
        return regexp.test(symbol);
    }
    checkBinary = function (symbol) {
            symbol = symbol.toString();
            regexp = new RegExp("[\\^\\+\\-\\*\\/]+");
            return regexp.test(symbol);
        }
    checkUnary = function (symbol) {
            return false;
        }
    checkPriority = function (op_1, op_2) {
        var op1pr, op2pr;
        if (op_1 == '^') op1pr = 1;
        if (op_2 == '^') op2pr = 1;
        if (op_1 == '*' || op_1 == '/') op1pr = 0.5;
        if (op_2 == '*' || op_2 == '/') op2pr = 0.5;
        if (op_1 == '+' || op_1 == '-') op1pr = 0.1;
        if (op_2 == '+' || op_2 == '-') op2pr = 0.1;
        //if (op_1 == '(') op_1pr = 0;
        if (op_2 == '(') op_2pr = 0;
        return op1pr - op2pr;
    }
    polishNotation = function (equalSTR) {
        var stack = [];
        var N = equalSTR.length;
        var return_string = "";
        for (var i = 0; i < N; i++) {
            var current_symbol = equalSTR.charAt(i);
            if ((current_symbol <= '9' && current_symbol >= '0')) {
                return_string += '#';
                while ((current_symbol <= '9' && current_symbol >= '0') || current_symbol == '.') {
                    return_string += (current_symbol);
                    current_symbol = equalSTR.charAt(++i);
                }
                i--;
            } else {
                if (current_symbol == ')') {
                    while (current_symbol != '(') {
                        current_symbol = stack.pop();
                        if (current_symbol != '(')
                            return_string += (current_symbol);
                    }
                    //stack.pop();
//                        if (stack.length > 0) {
//                            current_symbol = stack[stack.length - 1];
//                            if (checkOperation(current_symbol)) {
//                                stack.pop();
//                                return_string += (current_symbol);
//                            }
//                        }
                } else if (current_symbol != '(') {
                    while (checkPriority(current_symbol, stack[stack.length - 1]) <= 0) {
                        return_string += (stack.pop());
                    }
                    stack.push(current_symbol);
                } else stack.push(current_symbol);
            }
        }
        while (stack.length != 0) {
            return_string += (stack.pop());
        }
        return return_string;
    }
    recursiveData = function (cur_pos, equalSTR) {
        var operands = 0;
        cur_sim = cur_pos - 1;
        if(checkBinary(equalSTR[cur_pos]))
        {
           while (operands != 2) {
               if (cur_sim >= 0 && equalSTR[cur_sim] >= '0' && equalSTR[cur_sim] <= '9') {
                   var k = 0;
                   var numSTR = "";
                   while (cur_sim - k >= 0 && equalSTR[cur_sim - k] != '#') {
                       numSTR += equalSTR[cur_sim - k];
                       k++;
                   }
                   numSTR = numSTR.split("").reverse().join("");
                   data.push({"name": numSTR, "parent": equalSTR[cur_pos]});
                   operands++;
                   cur_sim=cur_sim - k - 1;
                   continue;
               }
               else if (cur_sim >= 0 && checkOperation(equalSTR[cur_sim]))
               {
                   data.push({"name": equalSTR[cur_sim], "parent": equalSTR[cur_pos]});
                   operands++;
                   recursiveData(cur_sim,equalSTR);
                   continue;
               }
           }
        }
        else if(checkUnary(equalSTR[cur_pos]))
        {
            while (operands != 2) {
                if (cur_sim >= 0 && equalSTR[cur_sim] >= '0' && equalSTR[cur_sim] <= '9') {
                    var k = 0;
                    var numSTR = "";
                    while (cur_sim - k >= 0 && equalSTR[cur_sim - k] != '#') {
                        numSTR.add(equalSTR[cur_sim - k]);
                        k++;
                    }
                    numSTR = numSTR.split("").reverse().join("");
                    data.push({"name": numSTR, "parent": equalSTR[cur_pos]});
                    cur_sim=cur_sim - k - 1;
                    operands++;
                    continue;
                }
                else if (cur_sim >= 0 && checkOperation(equalSTR[cur_sim]))
                {
                    data.push({"name": equalSTR[cur_sim], "parent": equalSTR[cur_pos]});
                    operands++;
                    recursiveData(cur_sim,equalSTR);
                    continue;
                }
            }
        }
    }
    generateTree = function () {
        data = [
        ];
        var equalSTR = document.getElementById("equalText").value;
        equalSTR = polishNotation(equalSTR);
        data.push({"name": equalSTR[equalSTR.length-1], "parent": "start"});
        //var newSTR = equalSTR.split("").reverse().join("");
        current_position = equalSTR.length - 1;
        recursiveData(equalSTR.length - 1, equalSTR);
        dataMap = data.reduce(function (map, node) {
            map[node.name] = node;
            return map;
        }, {});
        treeData = [];
        data.forEach(function (node) {
            // add to parent
            var parent = dataMap[node.parent];
            if (parent) {
                // create child array if it doesn't exist
                (parent.children || (parent.children = []))
                    // add node to child array
                        .push(node);
            } else {
                // parent is null or missing
                treeData.push(node);
            }
        });
        root = treeData[0];
        update(root);
    }
    function update(source) {
        // Compute the new tree layout.
        var nodes = tree.nodes(root).reverse(),
                links = tree.links(nodes);

        // Normalize for fixed-depth.
        nodes.forEach(function (d) {
            d.y = d.depth * 180;
        });

        // Declare the nodes…
        var node = svg.selectAll("g.node")
                .data(nodes, function (d) {
                    return d.id || (d.id = ++i);
                });

        // Enter the nodes.
        var nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", function (d) {
                    return "translate(" + d.y + "," + d.x + ")";
                });

        nodeEnter.append("circle")
                .attr("r", 10)
                .style("fill", "#fff");

        nodeEnter.append("text")
                .attr("x", function (d) {
                    return d.children || d._children ? -13 : 13;
                })
                .attr("dy", ".35em")
                .attr("text-anchor", function (d) {
                    return d.children || d._children ? "end" : "start";
                })
                .text(function (d) {
                    return d.name;
                })
                .style("fill-opacity", 1);

        // Declare the links…
        var link = svg.selectAll("path.link")
                .data(links, function (d) {
                    return d.target.id;
                });

        // Enter the links.
        link.enter().insert("path", "g")
                .attr("class", "link")
                .attr("d", diagonal);

    }
    }
    var page = page();
</script>
</body>